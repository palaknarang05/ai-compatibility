import { gridColumnLookupSelector, gridRowTreeSelector, GRID_ROOT_GROUP_ID, gridRowsLookupSelector } from '@mui/x-data-grid-pro';
import { getVisibleRows } from '@mui/x-data-grid/internals';
export const shouldApplySorting = (aggregationRules, aggregatedFields) => {
  return aggregatedFields.some(field => aggregationRules[field].aggregationFunction.applySorting);
};
const getGroupAggregatedValue = (groupId, apiRef, aggregationRowsScope, aggregatedFields, aggregationRules, position, applySorting, valueGetters, publicApi, groupAggregatedValuesLookup) => {
  const groupAggregationLookup = {};
  const aggregatedValues = [];
  for (let i = 0; i < aggregatedFields.length; i += 1) {
    aggregatedValues[i] = {
      aggregatedField: aggregatedFields[i],
      values: []
    };
  }
  const rowTree = gridRowTreeSelector(apiRef);
  const rowLookup = gridRowsLookupSelector(apiRef);
  const isPivotActive = apiRef.current.state.pivoting.active;
  const rowIds = apiRef.current.getRowGroupChildren({
    groupId,
    applySorting,
    directChildrenOnly: true,
    skipAutoGeneratedRows: false,
    applyFiltering: aggregationRowsScope === 'filtered'
  });
  for (let i = 0; i < rowIds.length; i += 1) {
    const rowId = rowIds[i];
    const rowNode = rowTree[rowId];
    if (rowNode.type === 'group') {
      // MERGE EXISTING VALUES FROM THE LOOKUP TABLE
      const childGroupValues = groupAggregatedValuesLookup.get(rowId);
      if (childGroupValues) {
        for (let j = 0; j < aggregatedFields.length; j += 1) {
          aggregatedValues[j].values = aggregatedValues[j].values.concat(childGroupValues[j].values);
        }
      }
      continue;
    }
    const row = rowLookup[rowId];
    for (let j = 0; j < aggregatedFields.length; j += 1) {
      const aggregatedField = aggregatedFields[j];
      const columnAggregationRules = aggregationRules[aggregatedField];
      const aggregationFunction = columnAggregationRules.aggregationFunction;
      const field = aggregatedField;
      let value;
      if (typeof aggregationFunction.getCellValue === 'function') {
        value = aggregationFunction.getCellValue({
          field,
          row
        });
      } else if (isPivotActive) {
        // Since we know that pivoted fields are flat, we can use the row directly, and save lots of processing time
        value = row[field];
      } else {
        if (!row) {
          continue;
        }
        const valueGetter = valueGetters[aggregatedField];
        value = valueGetter(row);
      }
      if (value !== undefined) {
        aggregatedValues[j].values.push(value);
      }
    }
  }
  for (let i = 0; i < aggregatedValues.length; i += 1) {
    const {
      aggregatedField,
      values
    } = aggregatedValues[i];
    const aggregationFunction = aggregationRules[aggregatedField].aggregationFunction;
    const value = aggregationFunction.apply({
      values,
      groupId,
      field: aggregatedField // Added per user request in https://github.com/mui/mui-x/issues/6995#issuecomment-1327423455
    }, publicApi);
    groupAggregationLookup[aggregatedField] = {
      position,
      value
    };
  }
  return {
    groupAggregationLookup,
    aggregatedValues
  };
};
const getGroupAggregatedValueDataSource = (groupId, apiRef, aggregatedFields, position) => {
  const groupAggregationLookup = {};
  for (let j = 0; j < aggregatedFields.length; j += 1) {
    const aggregatedField = aggregatedFields[j];
    groupAggregationLookup[aggregatedField] = {
      position,
      value: apiRef.current.resolveGroupAggregation?.(groupId, aggregatedField) ?? ''
    };
  }
  return groupAggregationLookup;
};
export const createAggregationLookup = ({
  apiRef,
  aggregationRules,
  aggregatedFields,
  aggregationRowsScope,
  getAggregationPosition,
  isDataSource,
  applySorting = false
}) => {
  if (aggregatedFields.length === 0) {
    return {};
  }
  const columnsLookup = gridColumnLookupSelector(apiRef);
  const valueGetters = {};
  for (let i = 0; i < aggregatedFields.length; i += 1) {
    const field = aggregatedFields[i];
    const column = columnsLookup[field];
    const valueGetter = row => apiRef.current.getRowValue(row, column);
    valueGetters[field] = valueGetter;
  }
  const aggregationLookup = {};
  const rowTree = gridRowTreeSelector(apiRef);
  const groupAggregatedValuesLookup = new Map();
  const {
    rowIdToIndexMap
  } = getVisibleRows(apiRef);
  const createGroupAggregationLookup = groupNode => {
    let children = groupNode.children;
    if (applySorting) {
      children = children.toSorted((a, b) => rowIdToIndexMap.get(a) - rowIdToIndexMap.get(b));
    }
    for (let i = 0; i < children.length; i += 1) {
      const childId = children[i];
      const childNode = rowTree[childId];
      if (childNode.type === 'group') {
        createGroupAggregationLookup(childNode);
      }
    }
    const position = getAggregationPosition(groupNode);
    if (position !== null) {
      if (isDataSource) {
        aggregationLookup[groupNode.id] = getGroupAggregatedValueDataSource(groupNode.id, apiRef, aggregatedFields, position);
      } else if (groupNode.children.length) {
        const result = getGroupAggregatedValue(groupNode.id, apiRef, aggregationRowsScope, aggregatedFields, aggregationRules, position, applySorting, valueGetters, apiRef.current, groupAggregatedValuesLookup);
        aggregationLookup[groupNode.id] = result.groupAggregationLookup;
        groupAggregatedValuesLookup.set(groupNode.id, result.aggregatedValues);
      }
    }
  };
  createGroupAggregationLookup(rowTree[GRID_ROOT_GROUP_ID]);
  return aggregationLookup;
};