import {
  createSelector,
  generateTreeItemIdAttribute,
  selectorTreeViewId,
  useSelector,
  useTreeViewContext
} from "./chunk-ZCH6Y5JV.js";
import {
  extractEventHandlers_default
} from "./chunk-C4IKJ7MH.js";
import {
  useForkRef
} from "./chunk-E4MPIUBI.js";
import {
  useEnhancedEffect_default
} from "./chunk-VXIN4Z4C.js";
import {
  _extends
} from "./chunk-EQCCHGRT.js";
import {
  require_react
} from "./chunk-BQYK6RGN.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@mui/x-tree-view/esm/useTreeItem/useTreeItem.js
var React3 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.itemPlugin.js
var React = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.utils.js
var TREE_VIEW_ROOT_PARENT_ID = "__TREE_VIEW_ROOT_PARENT_ID__";
var buildSiblingIndexes = (siblings) => {
  const siblingsIndexLookup = {};
  siblings.forEach((childId, index) => {
    siblingsIndexLookup[childId] = index;
  });
  return siblingsIndexLookup;
};
var isItemDisabled = (itemMetaLookup, itemId) => {
  if (itemId == null) {
    return false;
  }
  let itemMeta = itemMetaLookup[itemId];
  if (!itemMeta) {
    return false;
  }
  if (itemMeta.disabled) {
    return true;
  }
  while (itemMeta.parentId != null) {
    itemMeta = itemMetaLookup[itemMeta.parentId];
    if (!itemMeta) {
      return false;
    }
    if (itemMeta.disabled) {
      return true;
    }
  }
  return false;
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewItems/useTreeViewItems.selectors.js
var selectorTreeViewItemsState = (state) => state.items;
var selectorIsTreeViewLoading = createSelector(selectorTreeViewItemsState, (items) => items.loading);
var selectorGetTreeViewError = createSelector(selectorTreeViewItemsState, (items) => items.error);
var selectorItemMetaLookup = createSelector(selectorTreeViewItemsState, (items) => items.itemMetaLookup);
var EMPTY_CHILDREN = [];
var selectorItemOrderedChildrenIds = createSelector([selectorTreeViewItemsState, (_, itemId) => itemId], (itemsState, itemId) => itemsState.itemOrderedChildrenIdsLookup[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? EMPTY_CHILDREN);
var selectorItemModel = createSelector([selectorTreeViewItemsState, (_, itemId) => itemId], (itemsState, itemId) => itemsState.itemModelLookup[itemId]);
var selectorItemMeta = createSelector([selectorItemMetaLookup, (_, itemId) => itemId], (itemMetaLookup, itemId) => itemMetaLookup[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? null);
var selectorIsItemDisabled = createSelector([selectorItemMetaLookup, (_, itemId) => itemId], isItemDisabled);
var selectorItemIndex = createSelector([selectorTreeViewItemsState, selectorItemMeta], (itemsState, itemMeta) => {
  if (itemMeta == null) {
    return -1;
  }
  const parentIndexes = itemsState.itemChildrenIndexesLookup[itemMeta.parentId ?? TREE_VIEW_ROOT_PARENT_ID];
  return parentIndexes[itemMeta.id];
});
var selectorItemParentId = createSelector([selectorItemMeta], (itemMeta) => itemMeta?.parentId ?? null);
var selectorItemDepth = createSelector([selectorItemMeta], (itemMeta) => itemMeta?.depth ?? 0);
var selectorDisabledItemFocusable = createSelector([selectorTreeViewItemsState], (itemsState) => itemsState.disabledItemsFocusable);
var selectorCanItemBeFocused = createSelector([selectorDisabledItemFocusable, selectorIsItemDisabled], (disabledItemsFocusable, isDisabled) => {
  if (disabledItemsFocusable) {
    return true;
  }
  return !isDisabled;
});

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.selectors.js
var selectorTreeViewLabelState = (state) => state.label;
var selectorIsItemEditable = createSelector([selectorTreeViewLabelState, (state, itemId) => selectorItemModel(state, itemId)], (labelState, itemModel) => {
  if (!itemModel || !labelState) {
    return false;
  }
  if (typeof labelState.isItemEditable === "boolean") {
    return labelState.isItemEditable;
  }
  return labelState.isItemEditable(itemModel);
});
var selectorIsItemBeingEdited = createSelector([selectorTreeViewLabelState, (_, itemId) => itemId], (labelState, itemId) => itemId ? labelState?.editedItemId === itemId : false);
var selectorIsAnyItemBeingEdited = createSelector(selectorTreeViewLabelState, (labelState) => !!labelState?.editedItemId);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.itemPlugin.js
var useTreeViewLabelItemPlugin = ({
  props
}) => {
  const {
    store
  } = useTreeViewContext();
  const {
    label,
    itemId
  } = props;
  const [labelInputValue, setLabelInputValue] = React.useState(label);
  const isItemEditable = useSelector(store, selectorIsItemEditable, itemId);
  const isItemBeingEdited = useSelector(store, selectorIsItemBeingEdited, itemId);
  React.useEffect(() => {
    if (!isItemBeingEdited) {
      setLabelInputValue(label);
    }
  }, [isItemBeingEdited, label]);
  return {
    propsEnhancers: {
      label: () => ({
        editable: isItemEditable
      }),
      labelInput: ({
        externalEventHandlers,
        interactions
      }) => {
        if (!isItemEditable) {
          return {};
        }
        const handleKeydown = (event) => {
          externalEventHandlers.onKeyDown?.(event);
          if (event.defaultMuiPrevented) {
            return;
          }
          const target = event.target;
          if (event.key === "Enter" && target.value) {
            interactions.handleSaveItemLabel(event, target.value);
          } else if (event.key === "Escape") {
            interactions.handleCancelItemLabelEditing(event);
          }
        };
        const handleBlur = (event) => {
          externalEventHandlers.onBlur?.(event);
          if (event.defaultMuiPrevented) {
            return;
          }
          if (event.target.value) {
            interactions.handleSaveItemLabel(event, event.target.value);
          }
        };
        const handleInputChange = (event) => {
          externalEventHandlers.onChange?.(event);
          setLabelInputValue(event.target.value);
        };
        return {
          value: labelInputValue ?? "",
          "data-element": "labelInput",
          onChange: handleInputChange,
          onKeyDown: handleKeydown,
          onBlur: handleBlur,
          autoFocus: true,
          type: "text"
        };
      }
    }
  };
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLabel/useTreeViewLabel.js
var useTreeViewLabel = ({
  store,
  params
}) => {
  const setEditedItem = (editedItemId) => {
    if (editedItemId !== null) {
      const isEditable = selectorIsItemEditable(store.value, editedItemId);
      if (!isEditable) {
        return;
      }
    }
    store.update((prevState) => _extends({}, prevState, {
      label: _extends({}, prevState.label, {
        editedItemId
      })
    }));
  };
  const updateItemLabel = (itemId, label) => {
    if (!label) {
      throw new Error(["MUI X: The Tree View component requires all items to have a `label` property.", "The label of an item cannot be empty.", itemId].join("\n"));
    }
    store.update((prevState) => {
      const item = prevState.items.itemMetaLookup[itemId];
      if (item.label !== label) {
        return _extends({}, prevState, {
          items: _extends({}, prevState.items, {
            itemMetaLookup: _extends({}, prevState.items.itemMetaLookup, {
              [itemId]: _extends({}, item, {
                label
              })
            })
          })
        });
      }
      return prevState;
    });
    if (params.onItemLabelChange) {
      params.onItemLabelChange(itemId, label);
    }
  };
  useEnhancedEffect_default(() => {
    store.update((prevState) => _extends({}, prevState, {
      label: _extends({}, prevState.label, {
        isItemEditable: params.isItemEditable
      })
    }));
  }, [store, params.isItemEditable]);
  return {
    instance: {
      setEditedItem,
      updateItemLabel
    },
    publicAPI: {
      setEditedItem,
      updateItemLabel
    }
  };
};
useTreeViewLabel.itemPlugin = useTreeViewLabelItemPlugin;
useTreeViewLabel.applyDefaultValuesToParams = ({
  params
}) => _extends({}, params, {
  isItemEditable: params.isItemEditable ?? false
});
useTreeViewLabel.getInitialState = (params) => ({
  label: {
    isItemEditable: params.isItemEditable,
    editedItemId: null
  }
});
useTreeViewLabel.params = {
  onItemLabelChange: true,
  isItemEditable: true
};

// node_modules/@mui/x-tree-view/esm/internals/utils/plugins.js
var hasPlugin = (instance, plugin) => {
  const plugins = instance.getAvailablePlugins();
  return plugins.has(plugin);
};

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewExpansion/useTreeViewExpansion.selectors.js
var selectorExpansion = (state) => state.expansion;
var selectorExpandedItems = createSelector([selectorExpansion], (expansionState) => expansionState.expandedItems);
var selectorExpandedItemsMap = createSelector([selectorExpandedItems], (expandedItems) => {
  const expandedItemsMap = /* @__PURE__ */ new Map();
  expandedItems.forEach((id) => {
    expandedItemsMap.set(id, true);
  });
  return expandedItemsMap;
});
var selectorIsItemExpanded = createSelector([selectorExpandedItemsMap, (_, itemId) => itemId], (expandedItemsMap, itemId) => expandedItemsMap.has(itemId));
var selectorIsItemExpandable = createSelector([selectorItemMeta], (itemMeta) => itemMeta?.expandable ?? false);
var selectorItemExpansionTrigger = createSelector([selectorExpansion], (expansionState) => expansionState.expansionTrigger);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewSelection/useTreeViewSelection.selectors.js
var selectorTreeViewSelectionState = (state) => state.selection;
var selectorSelectionModel = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.selectedItems);
var selectorSelectionModelArray = createSelector([selectorSelectionModel], (selectedItems) => {
  if (Array.isArray(selectedItems)) {
    return selectedItems;
  }
  if (selectedItems != null) {
    return [selectedItems];
  }
  return [];
});
var selectorSelectionModelMap = createSelector([selectorSelectionModelArray], (selectedItems) => {
  const selectedItemsMap = /* @__PURE__ */ new Map();
  selectedItems.forEach((id) => {
    selectedItemsMap.set(id, true);
  });
  return selectedItemsMap;
});
var selectorIsItemSelected = createSelector([selectorSelectionModelMap, (_, itemId) => itemId], (selectedItemsMap, itemId) => selectedItemsMap.has(itemId));
var selectorIsMultiSelectEnabled = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.isEnabled && selectionState.isMultiSelectEnabled);
var selectorIsSelectionEnabled = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.isEnabled);
var selectorIsCheckboxSelectionEnabled = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.isCheckboxSelectionEnabled);
var selectorIsItemSelectionEnabled = createSelector([selectorIsItemDisabled, selectorIsSelectionEnabled], (isItemDisabled2, isSelectionEnabled) => isSelectionEnabled && !isItemDisabled2);
var selectorSelectionPropagationRules = createSelector([selectorTreeViewSelectionState], (selectionState) => selectionState.selectionPropagation);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewFocus/useTreeViewFocus.selectors.js
var selectorTreeViewFocusState = (state) => state.focus;
var selectorDefaultFocusableItemId = createSelector([selectorSelectionModelArray, selectorExpandedItemsMap, selectorItemMetaLookup, selectorDisabledItemFocusable, (state) => selectorItemOrderedChildrenIds(state, null)], (selectedItems, expandedItemsMap, itemMetaLookup, disabledItemsFocusable, orderedRootItemIds) => {
  const firstSelectedItem = selectedItems.find((itemId) => {
    if (!disabledItemsFocusable && isItemDisabled(itemMetaLookup, itemId)) {
      return false;
    }
    const itemMeta = itemMetaLookup[itemId];
    return itemMeta && (itemMeta.parentId == null || expandedItemsMap.has(itemMeta.parentId));
  });
  if (firstSelectedItem != null) {
    return firstSelectedItem;
  }
  const firstNavigableItem = orderedRootItemIds.find((itemId) => disabledItemsFocusable || !isItemDisabled(itemMetaLookup, itemId));
  if (firstNavigableItem != null) {
    return firstNavigableItem;
  }
  return null;
});
var selectorIsItemTheDefaultFocusableItem = createSelector([selectorDefaultFocusableItemId, (_, itemId) => itemId], (defaultFocusableItemId, itemId) => defaultFocusableItemId === itemId);
var selectorFocusedItemId = createSelector(selectorTreeViewFocusState, (focus) => focus.focusedItemId);
var selectorIsItemFocused = createSelector([selectorFocusedItemId, (_, itemId) => itemId], (focusedItemId, itemId) => focusedItemId === itemId);

// node_modules/@mui/x-tree-view/esm/internals/plugins/useTreeViewLazyLoading/useTreeViewLazyLoading.selectors.js
var selectorLazyLoading = (state) => state.lazyLoading;
var selectorLazyLoadingOptional = (state) => state.lazyLoading;
var selectorDataSourceState = createSelector([selectorLazyLoading], (lazyLoading) => lazyLoading.dataSource);
var selectorIsLazyLoadingEnabled = createSelector([selectorLazyLoadingOptional], (lazyLoading) => !!lazyLoading?.enabled);
var selectorIsItemLoading = createSelector([selectorDataSourceState, (_, itemId) => itemId], (dataSourceState, itemId) => dataSourceState.loading[itemId] || false);
var selectorGetTreeItemError = createSelector([selectorDataSourceState, (_, itemId) => itemId], (dataSourceState, itemId) => dataSourceState.errors[itemId] || null);

// node_modules/@mui/x-tree-view/esm/hooks/useTreeItemUtils/useTreeItemUtils.js
var itemHasChildren = (reactChildren) => {
  if (Array.isArray(reactChildren)) {
    return reactChildren.length > 0 && reactChildren.some(itemHasChildren);
  }
  return Boolean(reactChildren);
};
var useTreeItemUtils = ({
  itemId,
  children
}) => {
  const {
    instance,
    store,
    publicAPI
  } = useTreeViewContext();
  const isItemExpandable = useSelector(store, selectorIsItemExpandable, itemId);
  const isLazyLoadingEnabled = useSelector(store, selectorIsLazyLoadingEnabled);
  const isMultiSelectEnabled = useSelector(store, selectorIsMultiSelectEnabled);
  const loading = useSelector(store, (state) => isLazyLoadingEnabled ? selectorIsItemLoading(state, itemId) : false);
  const error = useSelector(store, (state) => isLazyLoadingEnabled ? Boolean(selectorGetTreeItemError(state, itemId)) : false);
  const isExpandable = itemHasChildren(children) || isItemExpandable;
  const isExpanded = useSelector(store, selectorIsItemExpanded, itemId);
  const isFocused = useSelector(store, selectorIsItemFocused, itemId);
  const isSelected = useSelector(store, selectorIsItemSelected, itemId);
  const isDisabled = useSelector(store, selectorIsItemDisabled, itemId);
  const isEditing = useSelector(store, selectorIsItemBeingEdited, itemId);
  const isEditable = useSelector(store, selectorIsItemEditable, itemId);
  const status = {
    expandable: isExpandable,
    expanded: isExpanded,
    focused: isFocused,
    selected: isSelected,
    disabled: isDisabled,
    editing: isEditing,
    editable: isEditable,
    loading,
    error
  };
  const handleExpansion = (event) => {
    if (status.disabled) {
      return;
    }
    if (!status.focused) {
      instance.focusItem(event, itemId);
    }
    const multiple = isMultiSelectEnabled && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (status.expandable && !(multiple && selectorIsItemExpanded(store.value, itemId))) {
      instance.setItemExpansion({
        event,
        itemId
      });
    }
  };
  const handleSelection = (event) => {
    if (status.disabled) {
      return;
    }
    if (!status.focused && !status.editing) {
      instance.focusItem(event, itemId);
    }
    const multiple = isMultiSelectEnabled && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (multiple) {
      if (event.shiftKey) {
        instance.expandSelectionRange(event, itemId);
      } else {
        instance.setItemSelection({
          event,
          itemId,
          keepExistingSelection: true
        });
      }
    } else {
      instance.setItemSelection({
        event,
        itemId,
        shouldBeSelected: true
      });
    }
  };
  const handleCheckboxSelection = (event) => {
    const hasShift = event.nativeEvent.shiftKey;
    if (isMultiSelectEnabled && hasShift) {
      instance.expandSelectionRange(event, itemId);
    } else {
      instance.setItemSelection({
        event,
        itemId,
        keepExistingSelection: isMultiSelectEnabled,
        shouldBeSelected: event.target.checked
      });
    }
  };
  const toggleItemEditing = () => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (isEditing) {
      instance.setEditedItem(null);
    } else {
      instance.setEditedItem(itemId);
    }
  };
  const handleSaveItemLabel = (event, newLabel) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (selectorIsItemBeingEdited(store.value, itemId)) {
      instance.updateItemLabel(itemId, newLabel);
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const handleCancelItemLabelEditing = (event) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (selectorIsItemBeingEdited(store.value, itemId)) {
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const interactions = {
    handleExpansion,
    handleSelection,
    handleCheckboxSelection,
    toggleItemEditing,
    handleSaveItemLabel,
    handleCancelItemLabelEditing
  };
  return {
    interactions,
    status,
    publicAPI
  };
};

// node_modules/@mui/x-tree-view/esm/internals/TreeViewItemDepthContext/TreeViewItemDepthContext.js
var React2 = __toESM(require_react(), 1);
var TreeViewItemDepthContext = React2.createContext(() => -1);
if (true) TreeViewItemDepthContext.displayName = "TreeViewItemDepthContext";

// node_modules/@mui/x-tree-view/esm/internals/utils/tree.js
var getLastNavigableItemInArray = (state, items) => {
  let itemIndex = items.length - 1;
  while (itemIndex >= 0 && !selectorCanItemBeFocused(state, items[itemIndex])) {
    itemIndex -= 1;
  }
  if (itemIndex === -1) {
    return void 0;
  }
  return items[itemIndex];
};
var getPreviousNavigableItem = (state, itemId) => {
  const itemMeta = selectorItemMeta(state, itemId);
  if (!itemMeta) {
    return null;
  }
  const siblings = selectorItemOrderedChildrenIds(state, itemMeta.parentId);
  const itemIndex = selectorItemIndex(state, itemId);
  if (itemIndex === 0) {
    return itemMeta.parentId;
  }
  let previousNavigableSiblingIndex = itemIndex - 1;
  while (!selectorCanItemBeFocused(state, siblings[previousNavigableSiblingIndex]) && previousNavigableSiblingIndex >= 0) {
    previousNavigableSiblingIndex -= 1;
  }
  if (previousNavigableSiblingIndex === -1) {
    if (itemMeta.parentId == null) {
      return null;
    }
    return getPreviousNavigableItem(state, itemMeta.parentId);
  }
  let currentItemId = siblings[previousNavigableSiblingIndex];
  let lastNavigableChild = getLastNavigableItemInArray(state, selectorItemOrderedChildrenIds(state, currentItemId));
  while (selectorIsItemExpanded(state, currentItemId) && lastNavigableChild != null) {
    currentItemId = lastNavigableChild;
    lastNavigableChild = getLastNavigableItemInArray(state, selectorItemOrderedChildrenIds(state, currentItemId));
  }
  return currentItemId;
};
var getNextNavigableItem = (state, itemId) => {
  if (selectorIsItemExpanded(state, itemId)) {
    const firstNavigableChild = selectorItemOrderedChildrenIds(state, itemId).find((childId) => selectorCanItemBeFocused(state, childId));
    if (firstNavigableChild != null) {
      return firstNavigableChild;
    }
  }
  let itemMeta = selectorItemMeta(state, itemId);
  while (itemMeta != null) {
    const siblings = selectorItemOrderedChildrenIds(state, itemMeta.parentId);
    const currentItemIndex = selectorItemIndex(state, itemMeta.id);
    if (currentItemIndex < siblings.length - 1) {
      let nextItemIndex = currentItemIndex + 1;
      while (!selectorCanItemBeFocused(state, siblings[nextItemIndex]) && nextItemIndex < siblings.length - 1) {
        nextItemIndex += 1;
      }
      if (selectorCanItemBeFocused(state, siblings[nextItemIndex])) {
        return siblings[nextItemIndex];
      }
    }
    itemMeta = selectorItemMeta(state, itemMeta.parentId);
  }
  return null;
};
var getLastNavigableItem = (state) => {
  let itemId = null;
  while (itemId == null || selectorIsItemExpanded(state, itemId)) {
    const children = selectorItemOrderedChildrenIds(state, itemId);
    const lastNavigableChild = getLastNavigableItemInArray(state, children);
    if (lastNavigableChild == null) {
      return itemId;
    }
    itemId = lastNavigableChild;
  }
  return itemId;
};
var getFirstNavigableItem = (state) => selectorItemOrderedChildrenIds(state, null).find((itemId) => selectorCanItemBeFocused(state, itemId));
var findOrderInTremauxTree = (state, itemAId, itemBId) => {
  if (itemAId === itemBId) {
    return [itemAId, itemBId];
  }
  const itemMetaA = selectorItemMeta(state, itemAId);
  const itemMetaB = selectorItemMeta(state, itemBId);
  if (!itemMetaA || !itemMetaB) {
    return [itemAId, itemBId];
  }
  if (itemMetaA.parentId === itemMetaB.id || itemMetaB.parentId === itemMetaA.id) {
    return itemMetaB.parentId === itemMetaA.id ? [itemMetaA.id, itemMetaB.id] : [itemMetaB.id, itemMetaA.id];
  }
  const aFamily = [itemMetaA.id];
  const bFamily = [itemMetaB.id];
  let aAncestor = itemMetaA.parentId;
  let bAncestor = itemMetaB.parentId;
  let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
  let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
  let continueA = true;
  let continueB = true;
  while (!bAncestorIsCommon && !aAncestorIsCommon) {
    if (continueA) {
      aFamily.push(aAncestor);
      aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
      continueA = aAncestor !== null;
      if (!aAncestorIsCommon && continueA) {
        aAncestor = selectorItemParentId(state, aAncestor);
      }
    }
    if (continueB && !aAncestorIsCommon) {
      bFamily.push(bAncestor);
      bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
      continueB = bAncestor !== null;
      if (!bAncestorIsCommon && continueB) {
        bAncestor = selectorItemParentId(state, bAncestor);
      }
    }
  }
  const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;
  const ancestorFamily = selectorItemOrderedChildrenIds(state, commonAncestor);
  const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];
  const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];
  return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [itemAId, itemBId] : [itemBId, itemAId];
};
var getNonDisabledItemsInRange = (state, itemAId, itemBId) => {
  const getNextItem = (itemId) => {
    if (selectorIsItemExpandable(state, itemId) && selectorIsItemExpanded(state, itemId)) {
      return selectorItemOrderedChildrenIds(state, itemId)[0];
    }
    let itemMeta = selectorItemMeta(state, itemId);
    while (itemMeta != null) {
      const siblings = selectorItemOrderedChildrenIds(state, itemMeta.parentId);
      const currentItemIndex = selectorItemIndex(state, itemMeta.id);
      if (currentItemIndex < siblings.length - 1) {
        return siblings[currentItemIndex + 1];
      }
      itemMeta = itemMeta.parentId ? selectorItemMeta(state, itemMeta.parentId) : null;
    }
    throw new Error("Invalid range");
  };
  const [first, last] = findOrderInTremauxTree(state, itemAId, itemBId);
  const items = [first];
  let current = first;
  while (current !== last) {
    current = getNextItem(current);
    if (!selectorIsItemDisabled(state, current)) {
      items.push(current);
    }
  }
  return items;
};
var getAllNavigableItems = (state) => {
  let item = getFirstNavigableItem(state);
  const navigableItems = [];
  while (item != null) {
    navigableItems.push(item);
    item = getNextNavigableItem(state, item);
  }
  return navigableItems;
};
var isTargetInDescendants = (target, itemRoot) => {
  return itemRoot !== target.closest('*[role="treeitem"]');
};

// node_modules/@mui/x-tree-view/esm/useTreeItem/useTreeItem.js
var useTreeItem = (parameters) => {
  const {
    runItemPlugins,
    instance,
    publicAPI,
    store
  } = useTreeViewContext();
  const depthContext = React3.useContext(TreeViewItemDepthContext);
  const depth = useSelector(store, (...params) => {
    if (typeof depthContext === "function") {
      return depthContext(...params);
    }
    return depthContext;
  }, parameters.itemId);
  const {
    id,
    itemId,
    label,
    children,
    rootRef
  } = parameters;
  const {
    rootRef: pluginRootRef,
    contentRef,
    propsEnhancers
  } = runItemPlugins(parameters);
  const {
    interactions,
    status
  } = useTreeItemUtils({
    itemId,
    children
  });
  const rootRefObject = React3.useRef(null);
  const contentRefObject = React3.useRef(null);
  const handleRootRef = useForkRef(rootRef, pluginRootRef, rootRefObject);
  const handleContentRef = useForkRef(contentRef, contentRefObject);
  const checkboxRef = React3.useRef(null);
  const treeId = useSelector(store, selectorTreeViewId);
  const isSelectionEnabledForItem = useSelector(store, selectorIsItemSelectionEnabled, itemId);
  const isCheckboxSelectionEnabled = useSelector(store, selectorIsCheckboxSelectionEnabled);
  const idAttribute = generateTreeItemIdAttribute({
    itemId,
    treeId,
    id
  });
  const shouldBeAccessibleWithTab = useSelector(store, selectorIsItemTheDefaultFocusableItem, itemId);
  const sharedPropsEnhancerParams = {
    rootRefObject,
    contentRefObject,
    interactions
  };
  const createRootHandleFocus = (otherHandlers) => (event) => {
    otherHandlers.onFocus?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (!status.focused && selectorCanItemBeFocused(store.value, itemId) && event.currentTarget === event.target) {
      instance.focusItem(event, itemId);
    }
  };
  const createRootHandleBlur = (otherHandlers) => (event) => {
    otherHandlers.onBlur?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const rootElement = instance.getItemDOMElement(itemId);
    if (status.editing || // we can exit the editing state by clicking outside the input (within the Tree Item) or by pressing Enter or Escape -> we don't want to remove the focused item from the state in these cases
    // we can also exit the editing state by clicking on the root itself -> want to remove the focused item from the state in this case
    event.relatedTarget && isTargetInDescendants(event.relatedTarget, rootElement) && (event.target && event.target?.dataset?.element === "labelInput" && isTargetInDescendants(event.target, rootElement) || event.relatedTarget?.dataset?.element === "labelInput")) {
      return;
    }
    instance.removeFocusedItem();
  };
  const createRootHandleKeyDown = (otherHandlers) => (event) => {
    otherHandlers.onKeyDown?.(event);
    if (event.defaultMuiPrevented || event.target?.dataset?.element === "labelInput") {
      return;
    }
    instance.handleItemKeyDown(event, itemId);
  };
  const createLabelHandleDoubleClick = (otherHandlers) => (event) => {
    otherHandlers.onDoubleClick?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    interactions.toggleItemEditing();
  };
  const createContentHandleClick = (otherHandlers) => (event) => {
    otherHandlers.onClick?.(event);
    instance.handleItemClick(event, itemId);
    if (event.defaultMuiPrevented || checkboxRef.current?.contains(event.target)) {
      return;
    }
    if (selectorItemExpansionTrigger(store.value) === "content") {
      interactions.handleExpansion(event);
    }
    if (!isCheckboxSelectionEnabled) {
      interactions.handleSelection(event);
    }
  };
  const createContentHandleMouseDown = (otherHandlers) => (event) => {
    otherHandlers.onMouseDown?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.shiftKey || event.ctrlKey || event.metaKey || status.disabled) {
      event.preventDefault();
    }
  };
  const createIconContainerHandleClick = (otherHandlers) => (event) => {
    otherHandlers.onClick?.(event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (selectorItemExpansionTrigger(store.value) === "iconContainer") {
      interactions.handleExpansion(event);
    }
  };
  const getContextProviderProps = () => ({
    itemId,
    id
  });
  const getRootProps = (externalProps = {}) => {
    const externalEventHandlers = _extends({}, extractEventHandlers_default(parameters), extractEventHandlers_default(externalProps));
    let ariaSelected;
    if (status.selected) {
      ariaSelected = true;
    } else if (!isSelectionEnabledForItem) {
      ariaSelected = void 0;
    } else {
      ariaSelected = false;
    }
    const props = _extends({}, externalEventHandlers, {
      ref: handleRootRef,
      role: "treeitem",
      tabIndex: shouldBeAccessibleWithTab ? 0 : -1,
      id: idAttribute,
      "aria-expanded": status.expandable ? status.expanded : void 0,
      "aria-selected": ariaSelected,
      "aria-disabled": status.disabled || void 0
    }, externalProps, {
      style: _extends({}, externalProps.style ?? {}, {
        "--TreeView-itemDepth": depth
      }),
      onFocus: createRootHandleFocus(externalEventHandlers),
      onBlur: createRootHandleBlur(externalEventHandlers),
      onKeyDown: createRootHandleKeyDown(externalEventHandlers)
    });
    const enhancedRootProps = propsEnhancers.root?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, props, enhancedRootProps);
  };
  const getContentProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const props = _extends({}, externalEventHandlers, externalProps, {
      ref: handleContentRef,
      onClick: createContentHandleClick(externalEventHandlers),
      onMouseDown: createContentHandleMouseDown(externalEventHandlers),
      status
    });
    ["expanded", "selected", "focused", "disabled", "editing", "editable"].forEach((key) => {
      if (status[key]) {
        props[`data-${key}`] = "";
      }
    });
    const enhancedContentProps = propsEnhancers.content?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, props, enhancedContentProps);
  };
  const getCheckboxProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const props = _extends({}, externalEventHandlers, {
      ref: checkboxRef
    }, externalProps);
    const enhancedCheckboxProps = propsEnhancers.checkbox?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, props, enhancedCheckboxProps);
  };
  const getLabelProps = (externalProps = {}) => {
    const externalEventHandlers = _extends({}, extractEventHandlers_default(externalProps));
    const props = _extends({}, externalEventHandlers, {
      children: label
    }, externalProps, {
      onDoubleClick: createLabelHandleDoubleClick(externalEventHandlers)
    });
    const enhancedLabelProps = propsEnhancers.label?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, enhancedLabelProps, props);
  };
  const getLabelInputProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const enhancedLabelInputProps = propsEnhancers.labelInput?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, externalProps, enhancedLabelInputProps);
  };
  const getIconContainerProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    return _extends({}, externalEventHandlers, externalProps, {
      onClick: createIconContainerHandleClick(externalEventHandlers)
    });
  };
  const getErrorContainerProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    return _extends({}, externalEventHandlers, externalProps);
  };
  const getLoadingContainerProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    return _extends({
      size: "12px",
      thickness: 6
    }, externalEventHandlers, externalProps);
  };
  const getGroupTransitionProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const response = _extends({}, externalEventHandlers, {
      unmountOnExit: true,
      component: "ul",
      role: "group",
      in: status.expanded,
      children
    }, externalProps);
    return response;
  };
  const getDragAndDropOverlayProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const enhancedDragAndDropOverlayProps = propsEnhancers.dragAndDropOverlay?.(_extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    })) ?? {};
    return _extends({}, externalProps, enhancedDragAndDropOverlayProps);
  };
  return {
    getContextProviderProps,
    getRootProps,
    getContentProps,
    getGroupTransitionProps,
    getIconContainerProps,
    getCheckboxProps,
    getLabelProps,
    getLabelInputProps,
    getDragAndDropOverlayProps,
    getErrorContainerProps,
    getLoadingContainerProps,
    rootRef: handleRootRef,
    status,
    publicAPI
  };
};

export {
  TREE_VIEW_ROOT_PARENT_ID,
  buildSiblingIndexes,
  selectorIsTreeViewLoading,
  selectorGetTreeViewError,
  selectorItemMetaLookup,
  selectorItemOrderedChildrenIds,
  selectorItemModel,
  selectorItemMeta,
  selectorIsItemDisabled,
  selectorItemParentId,
  selectorItemDepth,
  selectorIsItemEditable,
  selectorIsItemBeingEdited,
  useTreeViewLabel,
  hasPlugin,
  selectorExpandedItems,
  selectorIsItemExpanded,
  selectorIsItemExpandable,
  selectorSelectionModel,
  selectorSelectionModelArray,
  selectorIsItemSelected,
  selectorIsMultiSelectEnabled,
  selectorIsSelectionEnabled,
  selectorIsCheckboxSelectionEnabled,
  selectorIsItemSelectionEnabled,
  selectorSelectionPropagationRules,
  selectorDefaultFocusableItemId,
  selectorFocusedItemId,
  TreeViewItemDepthContext,
  getPreviousNavigableItem,
  getNextNavigableItem,
  getLastNavigableItem,
  getFirstNavigableItem,
  findOrderInTremauxTree,
  getNonDisabledItemsInRange,
  getAllNavigableItems,
  isTargetInDescendants,
  useTreeItem
};
//# sourceMappingURL=chunk-F3ZZRCQ4.js.map
